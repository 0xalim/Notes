# The Abstraction: Address Space

important: every address generated by a user program is a virtual address

### Early Systems:
1. os set of routines (mostly libraries) sitting in memory
1. 1 running program that currently sits in physical memory

### Multiprogramming and time sharing
1. multiple programs sit in memory with their allocated space
1. you want protection; process should not be able to read/write  
 other processes memory

### Address Space
1. address space: abstraction of physical memory (for sec reasons)
1. components:
 1. memory state of the running program (code)
 1. stack keeps track of location in call chain, local vars  
     and pass params + return values to/from routines
 1. heap is dynamically allocated (static vars + objects)

1. location:
 1. code at top (static so easy to place)
 1. heap after code (grows downwards)
 1. stack at bottom (grows upwards)
 1. multiple threads is different

1. virtualizing memory:
 1. program thinks it's loaded into memory at x address
 1. when it access 0 it has to access local 0 not global 0
 1. the os + hardware support has to make sure this is true

crux: how does os build abstraction of private, large address space  
for multiple running process on top of single physical memory

1. goal:
 1. transparency: the program shouldn't realize it's  
     in virtual memory. should behave like it's in physical memory.
 1. efficiency: most efficient virt as possible (time+space). hardware 
     support (tlb's) necessary here
 1. protection: protect itself and other processes from one another. 
     should not affect memory content of other processes (outside 
     address space). i.e isolation.

fin
