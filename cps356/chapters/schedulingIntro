# Scheduling Introduction

crux: how to develop a framework for thinking about scheduling policies? key 
	assumptions? what approaches have been used already?

workload assumptions: {about processes}
	1. end goal: fully-operational scheduling discipline
	1. assumptions:
		1. each job runs for x amount of time
		1. all jobs arrive at same time
		1. one started, each job runs till completion
		1. all jobs only use cpu (no i/o)
		1. run-time of each job is known

scheduling metric:
	1. metric is something we use to measure something
	1. simple metric: turnaround time (performance based scheduling)
		1. time of completion - time of birth
		1. since all jobs start same time; tbirth = 0
		1. ultimately tturnaround = tcompletion

	1. another metric: fairness

fifo:
	1. first in first out
	1. dropping assumption 1 will lead to:
		1. the convoy affect: where short consumers get queued behind a
					heavy consumer.

shortest job first:
	1. runs the shortest job first, then the second shortest, etc.
	1. drop assumption 2:
		1. if the heavyweight consumer arrives before the lesser consumer
			then it's not different then a fifo (convoy affect)

	1. issue: non preemptive.

shortest time to completion first:
	1. drop assumption 3 + add timer interrupts + context switching
	1. can preempt jobs, run a shorter job and maybe continues the job it dropped
		later on.

response time:
	1. tresponse = tscheduler - tarrival

round robin:
	1. runs a job for a time slice (or time quantum) then switches to the next
	1. repeat switching until all jobs are finished
		1. length of time slice has to be multiple of timer-interrupt
	1. bad turn around rate (A finshes 13, B 14, C 15 and so on)
	1. very good response time however

comparison: {tradeoff - can't have your cake and eat it too}
	1. sjf, stcf good turnaround bad response time
	1. rr good response time bad turnaround

incorporating i/o:
	1. bad to run job A {as it requests i/o} and wait idling till it's done
		1. scheduler could make decision to run A after i/o done
			or continue with job B 

	1. good idea is to allow for overlap, while cpu is being used for job X
		while waiting for the i/o of another process to complete
		via splitting job X into sub-jobs.

final assumption:
	crux: removing the assumption that we know how long each job runs for, how
		do we build approaches for sjf/stcf without this information?

fin
