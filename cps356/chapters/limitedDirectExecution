/** What is limited direct execution **/
steps:
	- create entry in process list
	- allocate memory for program
	- load program into memory
	- set up stack 
	- execute main() call
					-run main()
					- execute return from main
	- free memory of process
	- remove from process list

idea:
	* running the program directly on cpu (direct execution)
	* issue:
		- how to make sure program doesn't do anything we dont want it to
		- how does os stop program from running + switch to another process
		  (time sharing requires virtualizing the cpu)

	
problem 1: Restricted Operations
	* cpu modes:
		- user mode: restricted to what program can do (no i/o request)
		- kernel mode: program can run what it likes (including i/o request)

	* issue: how to let user programs do some privileged operations?
		- system calls: allows kernel to carefully expose key pieces to
		  the program

	* trap instruction:
		- the instruction jumps into kernel raising the privilege level
		- the program then can do whatever it wants (if allowed)
		- finished; return-from-trap instruction to user privilege

	* how to stop program from jumping to whatever it wants?
		- via trap table during boot time
		- during boot pc is in kernel mode
		- os informs hardware of location of trap handlers with instrucitons
		- the hardware thus knows when system calls and execeptional events
		  take place

	* specifying system calls:
		- via system-call number; each system call has a number assigned
		- when os handles system call inside the trap handler
		  makes sure the correct number has been assigned+valid

		- this overhead serves as protection rather than program knowing
		  the exact address of something, it only knows this assigned number

LDE Protocol:
	* step 1: at boot time
		- kernel init's trap table
		- cpu remembers location for use

	* step 2: when running a process
		- kernel sets up things (nodes on process list, malloc) before 
		  using return-from-trap to start exec of process

		- cpu now in user mode; begins running process
		- when process issues system call, trap instruc, and return once again
		- program now completes all its work and returns from main()

problem 2: switching between processes
	* crux: When a process is running on the cpu, it means the os is not running. 
		So how can the os do anything at all? How does the os regain control
		of the cpu so it can switch between processes.

	* approach 1: cooperative
		- via a trust that the process will give control back via system call
		- so when the process starts reading a file, writing, or w/e it 
		  does a system call (yield) to regive control

		- when a process does an illegal task it also gives back control
		  (e.g divide by 0 or access memoery it shouldn't)

		- problem: what if the process never gives control back? (e.g) calls
		  the yield system call

	* approach 2: uncooperative
		- crux: how to prevent rogue processes that take control of the 
			machine

		- problem solved: timer interrupt; every so many seconds/mseconds
				  an interrupt is raised so the process halts 

		- at boot time os decides what code to run when timer interrupts
		- at boot time os starts time which is privileged operation
		- timer can also be turned off (concurrency later)
		- hardware has responsibility to save enough of process state so that
		  when it starts running again it is able to do so where it left off.

		- ^ this process is similar to explicit trap in kernel where registers
		  stack, etc is stored and easily restored via return from trap

	* saving and restoring:
		- context switch: save few registers values to kernel stack or other
		  space and restore a few for soon-to-be-executing process (from
		  kernel stack)

		- making sure when return-from-trap instruction is called it doesn't
		  return to process that was running but executes another process

		- to save context, low level assembly is run to save genPurpose
		  registers, pointers and such as saved and switches to the kernel
		  stack for the soon-to-be-executing process.

	* quick note on concurrency:
		- issue: what if a interrupt occurs during an interrupt/trap handling?
		- an easy method: disable interrupts while in an interrupt; however
				  this is leads to lost interrupts which is bad
				  (not sure why now)

		- another method: locking schemes to protect concurrent access
				  to internal data structures. however this becomes
				  complicated fast.

fin
