/** Chapter Overview **/
Crux: How do we provide illusion of many cpu's

time sharing: share time between processes so multiple can run
	* drawback: performance takes a hit

implementingVirt:
	* low-level machinery: (the how)
		- "mechanisms" are protocols that implement needed piece of func.
		   e.g "context" allows stopping of one process and start of another

	* high-level intelligence: (the which)
		- policies are algorithms to make decisions within the os.
		  e.g "scheduling policy", which processes should run next given
		  those in queue

		- scheduling policy values:
			historic call info
			workload knowledge
			performance mentrics+

machine state: what a processes can read/update at 'x' time it's running
	* address space: space in memory process can read/write to.
	* registers: instructions read/update from here. e.g
		- programCounter: wheres the next instruction
		- stack pointer: pointer at stack in lifo manner
		- frame pointer: function params, local vars, return address 

process api:
	* create: create a new process
	* destroy: destroy process forcefully
	* wait: wait until process stops running
	* misc controll: e.g suspension of process
	* status: interface for info on process

/** Process Creation **/
detail:
	* load code + static data (initialized vars) into address space
	* programs usually executable on disk/ssd; so os reads and puts in addSpace
	* old v. new:
		- old: eager loading
		- new: lazy loading {via paging+swapping (virt the memory)}

	* after code+static data is loaded, memory must be allocated for process
	  stack + init some parameters like main()

	* memory may also be allocated for heap (using malloc() in C) if using 
	  data structures and such. This memory is dynamically allocated.

	* some os (Like Unix) init tasks for I/O. Think stdin, stdout, stderror

	* finally jump to main() transferring control of cpu to process.


process states:
	* running: process running on processor, executing instructions.
	* ready: ready to run but os has not chosen to run it yet.
	* blocked: process not ready, e.g initiates a I/O request to disk

data structure:
	* first of many, the process list keeps track of all processes
	* many types of information need to be stored for processes that are blocked
	  so that when they start back up, they have all the info they need

	* context switching: stopped processes register saved to memory location,
			     and then restoring the registers to resume process.

	* different processes states:
		- zombie: child process done waiting for parent process
			  (0 in Unix if everything is correct, otherwise error)

		- Unused
		- Embryo
		- Sleeping, etc

fin
