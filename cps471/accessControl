# Author: Ash+
# Date Created: Saturday Feb  27 10:15:00 AM EST 2021
# Last Date Modified: Sat Mar  6 06:45:37 PM EST 2021
# File Name: accessControl
# Course: CPS 471
# Instructor: Baldwin


# This is chapter 4 of Compsec Principles && Practice (William Stallings)
# These notes are taken off the lecture powerpoints 

~~
RFC4949:
	* compSec: measures that assure in particular access control service

accessControl:
	* specific users have specific access to resources in a system

accessControlPolicies:
	* Discretionary:
		- based on identity on requester (wat they can/cant do)
	
	* Mandatory:
		- Security labels (top-secret, confidential, etc)
		- Cannot be overriden

	* Role-based:
		- engineer, auditor, department head, supervisor, etc
		- these roles define access you have

	* Attribute:
		- Security enviro, time user has been defined, etc

subject:
	* entity capable of accessing data (objects/users)

object:
	* resource which has controlled access
	* entity containing / accessing information

accessRight:
	* way a subject accesses the object (read/write/exec)

DAC:
	* privi user giving other users privi or not
	* defining the users, and then defining their privi
	* entry in the 'matrix' indicates their rights for each object

accessControlMatrix:
	* simple table with every user, and files, and whether they can rwx, etc
	* implementation(A) is not an actual table, but a list
		- linked list: fileA -> user1(rwx) -> user2(r) -> /

	* implementation(B) capability listing:
		- linked list: user1 -> fileA(rwx) -> fileB(rw) -> /
	
accessControlFunction:
	* accessControl is not only file permission, but also:
		- Mem addressing hardware
		- process manager (can it wakeup xdaemon)
		- terminal/device manager
		- instruction decoding hardware
		- accessControlMonitor:
			i) controls / monitors the accessControlMatrix within a sys

accessControlSystemCommands:
	* see table
	* simulation of s0 and s over objects(files)

protectionDomain:
	* capability list
	* in access matrix, a row defines a protection domain
	* userX can spawn serviceA with access rights of userX
		- can be static (perma) / dynamic (can changexFil)

	* userMode:
		- privi instructions + protected memory cannot be exec'd

	* kernelMode:
		- privi instructions can be exec'd + protected memory can be accessed

unixFileAccessControl (inodes):
	* administered using inodes(index nodes):
		- inodes can have multiple aliases
		- active inode -> 1 file
		- inodes contain:
			i) file attributes
			ii) permissions
			iii) control info

		- disk contains table of all inodes (can be corrupt)
		- when file is opened inode -> main mem + stored in resident table

	* directories:
		- hierarchical tree
		- contains files / other directories
		- file names + pointers
	
unixFileAccessControl (ID):
	* has userID
	* groupID
	* belongs to specific group
	* security bits:
		- 9 bits -> rwx(owner;group;world)
		- in regards to directory:
			i) read -> listing files
			ii) write -> create, rename, delete files
			iii) exec -> allow access

		- last 3 bits:
			i) setUID -> masquerade  (not sure)
			ii) setGID -> masquerade (not sure)
			iii) sticky bit -> used to keep file in memory

	* superuser: exempt from all above rules

RBACModels:
  * constraint: users are not allowed to have multiple roles within a system
  * heirarchies: roles are have heirarchies, so you can inherit privi
  * combinedModel: constraint + heirarchies

roleHierarchy:
  * roles can inherit the permission of the child role
  * can also disallow certain parent roles to inherit privi on children:
      - so director does not inherit some permission as engineer, but has higher privi

Constraints:
  * users can only be assigned to one role (static or per session):
      - any permission can only be assigned to one role -> exclusive roles

  * Cardinality:
      - maximum amount of users per role
  
  * Prerequisite role:
      - Can only be assigned a role, if you meet prerequisite of already assigned role

attributeBased (ABAC):
  * to give auth need both conditions on -> resource + user
  * advantage is flexibility + expressive power
  * added complexity:
      - concern of having it come down to access per file / case

  * Web services use this (XACML)
  * Also used in some cloud services

ABACModelAttribute:
  * Subject:
      - user is active entity, allowing flow of information or change of system state
      - define identity and characteristic of user

  Object:
      - passive information entity (containing or receiving information)
      - object has attribute to increase perm, to make access control decisions

  Environment:
      - describes the technical, operational + situational context, regarding info access
      - mostly been ignored

  ABAC (ye no fucking clue mate.):
    * controls access by evaluating rules against attributes
    * relies on evaluation of attribute
    * allows unlimited number of attributes to satisfy access control

  ACABScenario:
    * decision is made upon:
      - subject, and its attributes (name, shit like this)
      - object, and its attributes (what it contains, etc)
      - the access control policy of the org. itself
      - environmental conditions (are we being attacked, ddos'd, etc)

    * Decisions are made via the access control mechanism taking all this into account
    * complexity lies within here ^

ACL vs ABAC:
  * ACL:
    - Subject tries to gain access
    - authorization (network access + identity credentials)
    - is the subject in the list to access / do what they are trying to do
    - enforcement (deny/accept)

  * ABAC:
    - subject tries to gain access
    - auth (network + identity credentials)
    - decision -> rules/policy + subject attributes
    - enforcement -> object attribute taken into account
    - environment may or may not be taken into account

ABACPolicies:
  * written with perspective of object security and privi available to users
  * privi represents users behaviour, defined by authority and policy

ICAMModel:
  * developed by us government
  * related to identity, credential + AC
  * whole idea:
    - create trusted identity representations of people / nonpeople entities
    - bind those identities to credentials:
        i) credential is object/data structure binded to token
    - use credential to gain auth to resoureces

ICAM:
  * credentialManagement:
    - sponsor -> need someone to get you in
    - enrollment -> enroll in database (biometric, fingerprint)
    - build credential
    - issue credential
    - lifecycle management -> updated/cancelled/revalidated

  identityManagement:
    - background check
    - on-boarding??
    - authoritative attribute sources
    - lifecycle management

  identityFederation: (who has say in this access management)
    - external agency
    - state/local govern
    - business partner
    - citizen

  accesManagement:
    - resourceManagement -> objects
    - priviManagement -> user rights
    - policyManagement -> by org.
    - logicalAccess
    - physicalAccess -> need to be in plant/operation room to gain access

identityManagement:
  * establish trustworthy digital identity, independant of application or context
  * most common is to create digital representation for this application or program
  * maintaining this identity
  * lifecycle management -> yup :D

credentialManagement:
  * manage lifecycle of the token (key, smart card)
  * five components:
    - sponsor needs credential to give credentials
    - user enrolls in credential:
      i) proofing
      ii) authoritative attribute data

    - production is produced
    - credential is issued to person or npe
    - credential is maintained over safe cycle

accessManagement:
  * how we give access to entities to resources
  * logical + physical access
  * internal / external element
  * purpose is to ensure identity verif. is made when user tries to gain access to anything
  * support elements:
      i) resource management
      ii) privi management
      iii) policy management

threeSupportElements:
  * resource management:
    - defining rules for resources
    - rules include credential requirements and user+resource attributes are required

  * privi management:
    - establishing and maintaining privi attributes
    - attributes basis for decisions to gaining access to physical+logical resources

  * policy management:
    - what is allowed/not allowed in access transaction

identityFederation:
  * partners that want to maintain the identity of this process 
  * addresses two qs's:
    - how to trust identity of external org's
    - how to vouch for identities of users in ur org, when they collaborate with external orgs

identityExchange:
  * identity service provider
  * possible contract with relying party
  * users who will use this identity to access resources (TOS agreement)

trustFramework:
  * open identity shit, no fucking idea
  * nonprofits who want to maintain this trust framework
  * exchange links shown in lecture


